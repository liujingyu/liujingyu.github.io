<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>JY</title>
		<description>JY的笔记本</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>HTTP</title>
				<description>&lt;h2 id=&quot;http是什么&quot;&gt;HTTP是什么&lt;/h2&gt;

&lt;p&gt;HTTP是Hypertext Transfer Protocol 的缩写，超文本传输协议&lt;/p&gt;

&lt;h2 id=&quot;为什么学习http&quot;&gt;为什么学习HTTP&lt;/h2&gt;

&lt;p&gt;网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论, 底层协议正是使用的Http协议。做为后端开发的同学，有必要了解底层的HTTP协议内容及实现逻辑，有利于我们清楚整个具体过程到底发生了什么。&lt;/p&gt;

&lt;h2 id=&quot;如何学习http&quot;&gt;如何学习HTTP&lt;/h2&gt;

&lt;h3 id=&quot;经典开源的http-server项目&quot;&gt;经典开源的HTTP Server项目&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/EZLippi/Tinyhttpd&quot;&gt;源码Tinyhttpd&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160413230616951&quot; alt=&quot;流程图&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阅读代码顺序 &lt;code class=&quot;highlighter-rouge&quot;&gt;main -&amp;gt; startup -&amp;gt; accept_request -&amp;gt; execute_cgi&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;每个函数作用
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;accept_request:  处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。
bad_request: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.
cat: 读取服务器上某个文件写到 socket 套接字。
cannot_execute: 主要处理发生在执行 cgi 程序时出现的错误。
error_die: 把错误信息写到 perror 并退出。
execute_cgi: 运行 cgi 程序的处理，也是个主要函数。
get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束。
headers: 把 HTTP 响应的头部写到套接字。
not_found: 主要处理找不到请求的文件时的情况。
sever_file: 调用 cat 把服务器文件返回给浏览器。
startup: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。
unimplemented: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker C 环境, 调试PHP源码用的Docker环境, 大家可以试试 &lt;a href=&quot;https://github.com/liujingyu/docker-debug-php-src&quot;&gt;docker-debug-php-src&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html&quot;&gt;GDB 工具参考&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/02/make.html&quot;&gt;Make 命令教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc2616/&quot;&gt;RFC文档&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;摘要&lt;/li&gt;
      &lt;li&gt;The Hypertext Transfer Protocol (HTTP) is an application-level
  protocol for distributed, collaborative, hypermedia information
  systems. It is a generic, stateless, protocol which can be used for
  many tasks beyond its use for hypertext, such as name servers and
  distributed object management systems, through extension of its
  request methods, error codes and headers [47]. A feature of HTTP is
  the typing and negotiation of data representation, allowing systems
  to be built independently of the data being transferred.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;HTTP has been in use by the World-Wide Web global information
  initiative since 1990. This specification defines the protocol
  referred to as “HTTP/1.1”, and is an update to RFC 2068 [33].&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/restful_api.html&quot;&gt;RESTful API 设计指南&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/09/restful.html&quot;&gt;理解RESTful架构&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u013644957/article/details/51147723&quot;&gt;Tinyhttpd for Ubuntu 14.04 中文详细注释版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Thu, 20 Feb 2020 00:00:00 +0800</pubDate>
				<link>/c%20protocol/2020/02/20/learn-http.html</link>
				<guid isPermaLink="true">/c%20protocol/2020/02/20/learn-http.html</guid>
			</item>
		
			<item>
				<title>C 语言 Demo示例学习</title>
				<description>&lt;h3 id=&quot;函数指针&quot;&gt;函数指针&lt;/h3&gt;

&lt;p&gt;函数指针是指向函数的指针变量。&lt;/p&gt;

&lt;p&gt;通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。&lt;/p&gt;

&lt;p&gt;函数指针可以像一般函数一样，用于调用函数、传递参数。&lt;/p&gt;

&lt;p&gt;函数指针变量的声明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int max(int x, int y)
{
    return x &amp;gt; y ? x : y;
}

int main(void)
{
    /* p 是函数指针 */
    int (* p)(int, int) = &amp;amp; max; // &amp;amp;可以省略
    int a, b, c, d;

    printf(&quot;请输入三个数字:&quot;);
    scanf(&quot;%d %d %d&quot;, &amp;amp; a, &amp;amp; b, &amp;amp; c);

    /* 与直接调用函数等价，d = max(max(a, b), c) */
    d = p(p(a, b), c);

    printf(&quot;最大的数字是: %d\n&quot;, d);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译执行，输出结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;请输入三个数字:1 2 3
最大的数字是: 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;回调函数&quot;&gt;回调函数&lt;/h3&gt;

&lt;p&gt;函数指针作为某个函数的参数&lt;/p&gt;

&lt;p&gt;函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。&lt;/p&gt;

&lt;p&gt;简单讲：回调函数是由别人的函数执行时调用你实现的函数。&lt;/p&gt;

&lt;h3 id=&quot;c-typedef&quot;&gt;C typedef&lt;/h3&gt;

&lt;p&gt;C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef unsigned char BYTE;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BYTE  b1, b2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef unsigned char byte;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;示例&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;

int main( )
{
   Book book;

   strcpy( book.title, &quot;C 教程&quot;);
   strcpy( book.author, &quot;Runoob&quot;);
   strcpy( book.subject, &quot;编程语言&quot;);
   book.book_id = 12345;

   printf( &quot;书标题 : %s\n&quot;, book.title);
   printf( &quot;书作者 : %s\n&quot;, book.author);
   printf( &quot;书类目 : %s\n&quot;, book.subject);
   printf( &quot;书 ID : %d\n&quot;, book.book_id);

   return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;typedef-vs-define&quot;&gt;typedef vs #define&lt;/h3&gt;

&lt;p&gt;#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。&lt;/li&gt;
  &lt;li&gt;typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是 #define 的最简单的用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

#define TRUE  1
#define FALSE 0

int main( )
{
   printf( &quot;TRUE 的值: %d\n&quot;, TRUE);
   printf( &quot;FALSE 的值: %d\n&quot;, FALSE);

   return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;枚举类型vs常量&quot;&gt;枚举类型vs常量&lt;/h3&gt;

&lt;p&gt;枚举常量是另外一种类型的常量。枚举是一个常量整型值的列表。&lt;/p&gt;

&lt;h3 id=&quot;c-enum枚举&quot;&gt;C enum(枚举)&lt;/h3&gt;

&lt;p&gt;枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。&lt;/p&gt;

&lt;p&gt;枚举语法定义格式为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum　枚举名　{枚举元素1,枚举元素2,……};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个看起来代码量就比较多，接下来我们看看使用枚举的方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;c-命令行参数&quot;&gt;C 命令行参数&lt;/h3&gt;

&lt;p&gt;执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。&lt;/p&gt;

&lt;p&gt;命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main( int argc, char *argv[] )
{
   if( argc == 2 )
   {
      printf(&quot;The argument supplied is %s\n&quot;, argv[1]);
   }
   else if( argc &amp;gt; 2 )
   {
      printf(&quot;Too many arguments supplied.\n&quot;);
   }
   else
   {
      printf(&quot;One argument expected.\n&quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用一个参数，编译并执行上面的代码，它会产生下列结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$./a.out testing
The argument supplied is testing
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;c-内存管理&quot;&gt;C 内存管理&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;void *calloc(int num, int size);&lt;/code&gt;
在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 &lt;code class=&quot;highlighter-rouge&quot;&gt;num*size&lt;/code&gt; 个字节长度的内存空间，并且每个字节的值都是0。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;void free(void *address);&lt;/code&gt;
该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;void *malloc(int num);&lt;/code&gt;
在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;void *realloc(void *address, int newsize);&lt;/code&gt;
该函数重新分配内存，把内存扩展到 newsize。&lt;/p&gt;

&lt;p&gt;注意：void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。&lt;/p&gt;

&lt;h4 id=&quot;动态分配内存&quot;&gt;动态分配内存&lt;/h4&gt;

&lt;p&gt;编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char name[100];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main()
{
   char name[100];
   char *description;

   strcpy(name, &quot;Zara Ali&quot;);

   /* 动态分配内存 */
   description = (char *)malloc( 200 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);
   }
   else
   {
      strcpy( description, &quot;Zara ali a DPS student in class 10th&quot;);
   }
   printf(&quot;Name = %s\n&quot;, name );
   printf(&quot;Description: %s\n&quot;, description );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;calloc(200, sizeof(char));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。&lt;/p&gt;

&lt;h4 id=&quot;重新调整内存的大小和释放内存&quot;&gt;重新调整内存的大小和释放内存&lt;/h4&gt;

&lt;p&gt;当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 free() 来释放内存。&lt;/p&gt;

&lt;p&gt;或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main()
{
   char name[100];
   char *description;

   strcpy(name, &quot;Zara Ali&quot;);

   /* 动态分配内存 */
   description = (char *)malloc( 30 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);
   }
   else
   {
      strcpy( description, &quot;Zara ali a DPS student.&quot;);
   }
   /* 假设您想要存储更大的描述信息 */
   description = (char *) realloc( description, 100 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);
   }
   else
   {
      strcat( description, &quot;She is in class 10th&quot;);
   }

   printf(&quot;Name = %s\n&quot;, name );
   printf(&quot;Description: %s\n&quot;, description );

   /* 使用 free() 函数释放内存 */
   free(description);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;c-预处理器&quot;&gt;C 预处理器&lt;/h3&gt;

&lt;p&gt;C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。&lt;/p&gt;

&lt;p&gt;所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;指令	描述
#define	定义宏
#include	包含一个源代码文件
#undef	取消已定义的宏
#ifdef	如果宏已经定义，则返回真
#ifndef	如果宏没有定义，则返回真
#if	如果给定条件为真，则编译下面代码
#else	#if 的替代方案
#elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
#endif	结束一个 #if……#else 条件编译块
#error	当遇到标准错误时，输出错误消息
#pragma	使用标准化方法，向编译器发布特殊的命令到编译器中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
				<pubDate>Mon, 10 Feb 2020 00:00:00 +0800</pubDate>
				<link>/c/2020/02/10/c-demo.html</link>
				<guid isPermaLink="true">/c/2020/02/10/c-demo.html</guid>
			</item>
		
			<item>
				<title>职业规划</title>
				<description>&lt;p&gt;前几天，听PM圈子的老师分享关于项目经理的职业规划，顺便分享了职业规划的大致框架。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/media/职业生涯规划.png&quot; alt=&quot;职业规划&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 08 Feb 2020 00:00:00 +0800</pubDate>
				<link>/plan/2020/02/08/work-plan.html</link>
				<guid isPermaLink="true">/plan/2020/02/08/work-plan.html</guid>
			</item>
		
			<item>
				<title>量化理论</title>
				<description>&lt;p&gt;演绎论证,它们的分支命题不是复合命题, 并且其有效性或无效性取决于这些非复合命题的内在逻辑结构。&lt;/p&gt;

&lt;p&gt;单称命题,介绍了个体变元符号x,个体常项符号(小写字母从a到u)以及表示属性的符号(大写字母)。介绍了命题函项概念: 个含有一个个体变元的表达式,当以一个个体常元代入个体変元时,它就変成一个陈述。因此,通过列举程序,可以从一个命题函项得到一个命题。&lt;/p&gt;

&lt;p&gt;如何用概括的方法,也就是通过使用“每个”、“没有”有些”等量词,从命题函项得到命题。介绍了全称量词(x),其含义是给定任何一个x”,以及存在量词(ヨx),其含义是“至少存在一个如此这般的x”。还用对当方阵表明了全称量化和存在量化之间的关系。&lt;/p&gt;

&lt;p&gt;怎样用命题函项和量词正确地符号化以下四种主要命题: A:全称肯定命题E:全称否定命题I:特称肯定命题O:特称否定命题还对A、E、I、O四种命题之间关系的现代解释进行了说明。&lt;/p&gt;

&lt;p&gt;通过增加以下四个附加规则,扩展了推论规则表: 全称列举,UI 全称概括,UG 存在列举,E 存在概括,EG并且说明了怎样用这四个和前面已提出的19条推论规则,构造演绎论证有效性的形式证明,这种证明涉及非复合命题的内部结构。&lt;/p&gt;

&lt;p&gt;如何设计含有一个、两个或三个个体的模型或可能域以及在该可能域中改写论证的各分支命题,由此用逻辑类推的反驳方法来证明一个涉及量词的论证的无效性。如果我们能展示这样一个可能域,即它至少含有一个使该论证的所有前提在域中为真而结论在其中为假的个体,那么,我们就证明了这个涉及量词的论证无效&lt;/p&gt;

&lt;p&gt;怎样对非三段论论证进行符号化和评价。这些论证含有些不能划归为A、E、I、O命题或单称命题的命题。鉴于除外命题和其他一些命题的复杂性,必须先理解它们的逻辑含义,然后才能用命题函项和量词进行准确的翻译。&lt;/p&gt;
</description>
				<pubDate>Sun, 19 Jan 2020 00:00:00 +0800</pubDate>
				<link>/logical/2020/01/19/quantitative-theory.html</link>
				<guid isPermaLink="true">/logical/2020/01/19/quantitative-theory.html</guid>
			</item>
		
			<item>
				<title>直言三段论</title>
				<description>&lt;p&gt;标准式直言三段论:
组成成分、形式、有效性和制约其正确使用的规则。&lt;/p&gt;

&lt;p&gt;三段论大项、小项和中项的定义:&lt;/p&gt;

&lt;p&gt;大项:结论的谓项&lt;/p&gt;

&lt;p&gt;小项:结论的主项&lt;/p&gt;

&lt;p&gt;中项:两个前提中都出现, 但结论中不出现的第三个项&lt;/p&gt;

&lt;p&gt;继而又分别定义了大前提和小前提,包含大项的前提叫做大前提,包含小项的前提叫做小前提。&lt;/p&gt;

&lt;p&gt;如果几个命题出现的次序正好是:大前提在第一位、小前提在第二位、结论在最后,我们就把这样的三段论指定为标准式的。&lt;/p&gt;

&lt;p&gt;三段论的式与格是如何确定的。
段论的式由识别三个命题类型的字母来确定,即A、E、1、O中的三个。总共有64个不同式。
段论的格由中项在前提中的不同位置来确定。&lt;/p&gt;

&lt;p&gt;对四个可能的格描述并定义如下:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一格&lt;/strong&gt;:中项在大前提中做主项、在小前提中做谓项。 模式为:M-P,S-M,所以S-P。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二格&lt;/strong&gt;:中项在两个前提中都儆谓项。 模式为:P-M,S-M,所以S-P&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三格&lt;/strong&gt;:中项在两个前提中都做主项。 模式为:M一P,M-S,所以S-P。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四格&lt;/strong&gt;:中项在大前提中做谓项、在小前提中做主项。 模式为:P-M,M-S,所以S-P。&lt;/p&gt;

&lt;p&gt;标准式三段论的式与格如何共同地确定其逻辑形式。由于64个式每一个都有四个格,所以共有256个标准式的直言三段论,但其中只有一小部分是有效式。&lt;/p&gt;

&lt;p&gt;标准式三段论的六条基本规则,同时定义了违反各条规则所造成的谬误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则1&lt;/strong&gt;一个有效的标准式直言三段论必须仅仅包含三个项,在整个论证中,每一个项都须在相同的意义上使用。&lt;/p&gt;

&lt;p&gt;违反本规则所犯的错误:四项谬误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则2&lt;/strong&gt;在一个有效的标准式直言三段论中,中项必须至少在一个前提中周延。&lt;/p&gt;

&lt;p&gt;违反本规则所犯的错误:中项不周延谬误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则3&lt;/strong&gt;在一个有效的标准式直言三段论中,在结论中周延的项在前提中也必须周延。&lt;/p&gt;

&lt;p&gt;违反本规则所犯的错误:大项不当周延谬误,或者小项不当周延谬误&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则4&lt;/strong&gt;任何有两个否定前提的标准式三段论都不是有效的。&lt;/p&gt;

&lt;p&gt;违反本规则所犯的错误:排斥前提谬误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则5&lt;/strong&gt;如果一个标准式三段论有一个前提是否定的,那么结论必须是否定的。&lt;/p&gt;

&lt;p&gt;违反本规则所犯的错误:从否定推肯定谬误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则6&lt;/strong&gt;一个有效的标准式直言三段论,如果结论为特称命题,那么其前提不能都是全称的。&lt;/p&gt;

&lt;p&gt;违反本规则所犯的错误:存在谬误。&lt;/p&gt;

&lt;p&gt;标准式直言三段论的15个有效形式的说明,识别它们的格与式,并说明了它们传统的拉丁名称:
AAA-1( Barbara)、EAE-1( parent)、AII1(Dari)、EIO-1(Fe rio)、AEE-2( Camestres)、EAE-2( Cesare)、AOO2( Baroko)、EIO2( Festino)、AII-3( Datisi)、IAI-3( Disamis)、EIO-3( Ferison)、OAO3 ( Bokardo)、AEE-4( amenes)、IAI-4( Dimaris)、EIO-4( Fresison)。&lt;/p&gt;

&lt;p&gt;15个有效形式的演绎推导,通过排除法程序,证明了只有15个形式是完全遵守三段论的六条基本规则的。&lt;/p&gt;
</description>
				<pubDate>Fri, 17 Jan 2020 00:00:00 +0800</pubDate>
				<link>/logical/2020/01/17/syllogism.html</link>
				<guid isPermaLink="true">/logical/2020/01/17/syllogism.html</guid>
			</item>
		
			<item>
				<title>谬误</title>
				<description>&lt;h3 id=&quot;什么是谬误&quot;&gt;什么是谬误&lt;/h3&gt;

&lt;p&gt;谬误是那种看起来正确但经过考察而证明并非如此的论证。&lt;/p&gt;

&lt;p&gt;谬误三大类非形式谬误：相干谬误、预设谬误和含混谬误。&lt;/p&gt;

&lt;h3 id=&quot;相干谬误&quot;&gt;相干谬误&lt;/h3&gt;

&lt;p&gt;相干谬误在这类谬误中,错误论证依赖于看起来可能与结论相关但事实上无关的前提。我们分七种相干谬误来解释这类推理错误。&lt;/p&gt;

&lt;p&gt;R1.诉诸无知论证:当以一命题没有被证明是假的为理由来论证该命题是真的,或当论证一命题是假的因为它没有被证明是真的。&lt;/p&gt;

&lt;p&gt;R2.诉诸不当权威:一个论证的前提诉诸某方或多方判断,而它或它们却不能合法地声称对手头问题具有权威。&lt;/p&gt;

&lt;p&gt;R3.人身攻击论证:攻击不是针对所做的主张或针对论证的优点, 而是针对对手本身。
人身攻击论证有两种形式。当攻击直接针对人,以寻求诋毁和侮辱他们时,就称做“诽谤性人身攻击论证”。当攻击间接地对准人,暗示他们坚持他们的观点主要是因为他们的特殊环境或利益时,就称做“背景性人身攻击论证”。&lt;/p&gt;

&lt;p&gt;R4.诉诸情感:细心推理被激起狂热或情感来支持预先结论的精心策划所取代。&lt;/p&gt;

&lt;p&gt;R5.诉诸同情:细心推理被激起听者同情来达到说者所关注目标的精心策划所取代。&lt;/p&gt;

&lt;p&gt;R6.诉诸武力:为了得到对某些结论的承诺,细心推理被直接或含沙射影的威胁所取代。&lt;/p&gt;

&lt;p&gt;R7.不相于结论:前提不得要领,声称支持一个结论而事实上却支持或证实另一个结论。&lt;/p&gt;

&lt;h3 id=&quot;预设谬误&quot;&gt;预设谬误&lt;/h3&gt;

&lt;p&gt;预设谬误在这类谬误中,错误论证源于依赖于某些被假定为真的命题,而这些命题实际上是假的、可疑的或没有得到证明的。我们分五种预设谬误来解释这类推理错误。&lt;/p&gt;

&lt;p&gt;P1.复杂问语:以问句预设了某些假设为真的方式来询向问题。&lt;/p&gt;

&lt;p&gt;P2.虚假原因:把一个东西当做一个事物的原因而它实际上并不是那个事物的原因,或更一般地说,在以因果关系为基础的推理中犯错&lt;/p&gt;

&lt;p&gt;P3.丐题:在某个论证前提中假定了结论要寻求确证的东西。&lt;/p&gt;

&lt;p&gt;P4.偶然:把某个概括运用于它不能适当管辖的个别情况P5.逆偶然:粗心大意地从单个情况转移到一个无辦护余地的广泛概括。&lt;/p&gt;

&lt;h3 id=&quot;含混谬误&quot;&gt;含混谬误&lt;/h3&gt;

&lt;p&gt;含混谬误在这类谬误中,错误论证的形成方式是,它依赖于词或短语从在前提中的用法到在结论中的用法的意义变化。我们分五种含混谬误来解释这类推理错误。&lt;/p&gt;

&lt;p&gt;A1.歧义:在论证的明确表述中,有意或无意地使用同一个词或短语的两个或更多意义。&lt;/p&gt;

&lt;p&gt;A2.双关:因为陈述中的词或短语结合得松散或笨拙,论证中的这个陈述具有多于一个合理意义。&lt;/p&gt;

&lt;p&gt;A3.重读:意义的变化作为对论证的词或短语的强调改变的结果而源于该论证之内。&lt;/p&gt;

&lt;p&gt;A4.合成:(a)错误地从部分性质到整体性质进行推理,(b)或者, 错误地从某汇集的个别分子性质到整个汇集的性质进行推理。&lt;/p&gt;

&lt;p&gt;A5.分解:(a)错误地从整体性质到它的一个部分的性质进行推理, (b)或者,错误地从某些实体汇集的某个全体性质到该汇集的个别实体性质进行推理。&lt;/p&gt;
</description>
				<pubDate>Fri, 17 Jan 2020 00:00:00 +0800</pubDate>
				<link>/logical/2020/01/17/logical-fallacy.html</link>
				<guid isPermaLink="true">/logical/2020/01/17/logical-fallacy.html</guid>
			</item>
		
			<item>
				<title>语言的用法</title>
				<description>&lt;p&gt;语言的多种用法和形式,以及可能由于没有认识到这些复杂性而引起的错解和滥用。&lt;/p&gt;

&lt;p&gt;语言的三种基本功能: &lt;strong&gt;信息性功能、表达性功能和指令性功能&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一个给定语段可能行使的多种功能的方式:同时行使两种甚或所有三种功能。&lt;/p&gt;

&lt;p&gt;标准语法形式的句子,即&lt;strong&gt;陈述句、疑问句、祈使句和感叹句&lt;/strong&gt;,并不总是行使与其名称相关的功能。陈述句可以用做指令性的或者表达性的功能;疑问句可以具有信息性的或指令性的功能,等等。语法形式不决定语言功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信念歧见与态度歧见&lt;/strong&gt;。冲突双方可以既在事实是什么上致也在对事实的态度上一致,或者在两方面都对立。他们可能在事实上致,而在对事实的态度上对立。他们还可能在事实是什么上对立,但在对他们所相信的事实的态度上却致。要解决歧见问题,了解其真正本性是极其重要的。&lt;/p&gt;

</description>
				<pubDate>Fri, 17 Jan 2020 00:00:00 +0800</pubDate>
				<link>/logical/2020/01/17/language-usage.html</link>
				<guid isPermaLink="true">/logical/2020/01/17/language-usage.html</guid>
			</item>
		
			<item>
				<title>定义</title>
				<description>&lt;p&gt;解释词项的意义就是给出它的定义。&lt;/p&gt;

&lt;p&gt;三种论争:&lt;/p&gt;

&lt;p&gt;1.明显的实质争论,其中没有语词歧义,而且论争双方的确在态度上或信念上对立。&lt;/p&gt;

&lt;p&gt;2.纯粹言辞之争,其中出现语词歧义,但根本没有实质歧见。&lt;/p&gt;

&lt;p&gt;3.表面上是言辞的但实际上是实质的论争,其中既存在语词歧义, 也存在论争双方在态度上或在信念上的歧见。&lt;/p&gt;

&lt;p&gt;定义总是符号的定义,并且引进了术语被定义项(被定义的符号)和定义项(用来解释被定义项意义的符号)。&lt;/p&gt;

&lt;p&gt;还在五种定义及其基本用法中进行了区分:&lt;/p&gt;

&lt;p&gt;1.规定定义,把一个意义指派给某个符号。规定定义不是报道,因而既不真也不假;它是运用被定义项来意指定义项指谓事物的建议、解决、请求或工具。&lt;/p&gt;

&lt;p&gt;2.词典定义,它报道被定义项已经具有的意义,因而它可以或对或错。&lt;/p&gt;

&lt;p&gt;3.精确定义,它超出了平常用法,用于消除与临界状况有关的麻烦的不确定性。其被定义项有一个现存的意义,但这个意义是模糊的;增添什么可以达至精确性,部分上是个规定问题。&lt;/p&gt;

&lt;p&gt;4.理论定义,它寻求对它的适用对象精确表述一个理论上足够或科学上有用的描述。&lt;/p&gt;

&lt;p&gt;5.说服定义,它运用表达性语言而不是信息性语言来寻求影响态度或激发情感。&lt;/p&gt;

&lt;p&gt;在这五种定义中,前两种(规定定义和词典定义)主要用于消除歧义;第三种(精确定义)主要用于降低模糊性;第四种(理论定义)用于促进理论理解;而第五种(说服定义)用于影响行为。&lt;/p&gt;

&lt;p&gt;普遍词项指谓其可以正确适用的多个对象。这些对象的汇集构成该词项的外延。说明了为词项外延中的所有对象并且仅为那些对象所共有的属性集就是该词项的内涵。词项的内涵决定其外延,但外延却不能决定内涵;因此,几个词项可以具有不同内涵而外延却相同;但外延不同的词项却不可能具有相同内涵。&lt;/p&gt;

&lt;p&gt;怎样利用普遍词项的外延来构造外延定义;外延定义有几种类型,其局限性也被揭示出来:&lt;/p&gt;

&lt;p&gt;1.列举定义,即在定义中列出或给出词项指谓对象的范例。&lt;/p&gt;

&lt;p&gt;2.实指定义,在定义时,我们用手指出或以姿势标明被定义项的外延。&lt;/p&gt;

&lt;p&gt;3.准实指定义,在定义中,姿势或手指的指示伴有一些其意义被认为是已为人所知的描述短语。&lt;/p&gt;

&lt;p&gt;怎样利用普遍词项的内涵来构建内涵定义;内涵定义也有几种类型,其局限性也被揭示出来:&lt;/p&gt;

&lt;p&gt;1.同义定义,在定义中提供另一个其意义已为人所知的词,这个词与被定义的词具有相同意义&lt;/p&gt;

&lt;p&gt;2.操作定义,它表明词项正确运用于一个给定场合,当且仅当,在该场合下特有的操作行为产生特有结果。&lt;/p&gt;

&lt;p&gt;3.属加种差定义,首先要找出一个属,被定义项所指代的种是该属的一个子类;然后找出属性(或种差),即把该种的分子与属的所有其他种的分子区分开来的那种属性。&lt;/p&gt;

&lt;p&gt;内涵定义的方法可以用于构建五种定义的任何一种: 规定定义、词典定义、精确定义、理论定义和说服定义。&lt;/p&gt;

&lt;p&gt;传统的属加种差定义的五条规则:&lt;/p&gt;

&lt;p&gt;1.定义应当揭示种的本质属性。&lt;/p&gt;

&lt;p&gt;2.定义不能循环。&lt;/p&gt;

&lt;p&gt;3.定义既不能过宽又不能过窄。&lt;/p&gt;

&lt;p&gt;4.定义不能用岐义的、晦涩的或比喻的语言来表述.定义在可以用肯定的地方就不应当用否定定义。&lt;/p&gt;
</description>
				<pubDate>Fri, 17 Jan 2020 00:00:00 +0800</pubDate>
				<link>/logical/2020/01/17/definition.html</link>
				<guid isPermaLink="true">/logical/2020/01/17/definition.html</guid>
			</item>
		
			<item>
				<title>直言命题</title>
				<description>&lt;p&gt;本章介绍并讨论的是古典逻辑即亚里士多德型逻辑的基本构件,也是演绎逻辑的基本构件。&lt;/p&gt;

&lt;p&gt;传统逻辑正是以类为基础建立起来的。我们闻明了四种基本的标准式直言命题&lt;/p&gt;

&lt;p&gt;A命题:全称肯定命题&lt;/p&gt;

&lt;p&gt;E命题:全称否定命题&lt;/p&gt;

&lt;p&gt;Ⅰ命题:特称肯定命题&lt;/p&gt;

&lt;p&gt;O命题:特称否定命题&lt;/p&gt;

&lt;p&gt;探讨了命题的质,即肯定和否定,以及命题的量,即全称和特称。说明了周延的项与不周延的项&lt;/p&gt;

&lt;p&gt;这几种直言命题之间的对当关系的种类:&lt;/p&gt;

&lt;p&gt;命题之间的矛盾关系、反对关系、下反对关系以及上位式与下位式之间的差等关系。&lt;/p&gt;

&lt;p&gt;并用个对当方阵图示了这几种关系,进而说明了一些基于传统方阵的直接推理。&lt;/p&gt;

&lt;p&gt;其他三种直接推论:换位法、换质法和換质位法。&lt;/p&gt;

&lt;p&gt;探讨存在含义问题。要保留传统对当方阵,只有做出一种假定,即全盘假定命题主项所指称的类总是有元素的一一这是现代逻辑极不赞同的。然后,我们又对本书通篇采用的布尔解释作了说明。布尔解释能保留传统逻辑对当方阵中的大部分内容,同时又避免了非空类的假定。在布尔解释中,特称命题,即称为I和O的命题之中有存在含义,但全称命题,即A和E则没有存在含义。我们也很细致地说明了采用这种解释的结果。&lt;/p&gt;

&lt;p&gt;直言命题符号化与图示化的方法,包括使用文恩图,用交叉的圆加以恰当的标记或阴影来刻画类与类之间的关系。&lt;/p&gt;

&lt;p&gt;有了这些必要的工具,我们就可以考察一一在接下来的两章中一建基于标准式直言命题之上的三段论,以及传统演绎逻辑在日常语言中的其他主要用途。&lt;/p&gt;
</description>
				<pubDate>Fri, 17 Jan 2020 00:00:00 +0800</pubDate>
				<link>/logical/2020/01/17/blunt-proposition.html</link>
				<guid isPermaLink="true">/logical/2020/01/17/blunt-proposition.html</guid>
			</item>
		
			<item>
				<title>逻辑学基本概念</title>
				<description>&lt;p&gt;&lt;strong&gt;逻辑学&lt;/strong&gt;定义为研究用于区分正确推理与不正确推理的方法和原理的学问。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;命题&lt;/strong&gt;是可以被肯定或否定,并且或真或假的东西。&lt;/p&gt;

&lt;p&gt;论证概念, 一串命题,其中之一是结论,另一个(或一些)是用以支持结论的前提。&lt;/p&gt;

&lt;p&gt;说明并且例示分析论证的方法种是&lt;strong&gt;解析法&lt;/strong&gt;,按照逻辑的顺序完整地列出论证中所有的命题;另一种是&lt;strong&gt;图示法&lt;/strong&gt;,所有命题都用数字标示,这些数字以一定的方式相互连接以展现命题之间的逻辑关系。&lt;/p&gt;

&lt;p&gt;讨论辨识论证的几个方面的问题,包括&lt;strong&gt;结论指示词&lt;/strong&gt;和&lt;strong&gt;前提指示词&lt;/strong&gt;、&lt;strong&gt;语境&lt;/strong&gt;在辨识前提和结论中的作用、有可能充当前提的非陈述形式以及包含未明确陈述出来的命题的论证等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;论证&lt;/strong&gt;和&lt;strong&gt;说明&lt;/strong&gt;之间的区别,解释为什么做出这种区分常常是困难的,这种区分依赖于语段的语境和作者的表达意图。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;演绎和有效性&lt;/strong&gt;,将演绎论证定义为断言其结论从前提必然9地得出的论证,一个有效的演绎论证就是一个假如其前提为真则结论必然为真的论证。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;归纳和或然性&lt;/strong&gt;,将归纳论证定义为其结论具有某种或然性程度,但并非(从前提)必然地得出的论证,说明归纳论证可以被判定好与坏,但不能刻画为有效与无效。&lt;/p&gt;

</description>
				<pubDate>Fri, 17 Jan 2020 00:00:00 +0800</pubDate>
				<link>/logical/2020/01/17/basic-concepts-of-logic.html</link>
				<guid isPermaLink="true">/logical/2020/01/17/basic-concepts-of-logic.html</guid>
			</item>
		
	</channel>
</rss>
