<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>JY</title>
	
	<meta name="author" content="JY">

	<!-- Enable responsive viewport -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="/assets/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<link href="/assets/resources/font-awesome/css/font-awesome.min.css" rel="stylesheet">
	<link href="/assets/resources/syntax/syntax.css" rel="stylesheet">
	<link href="/assets/css/style.css" rel="stylesheet">

	<!-- Le fav and touch icons -->
	<!-- Update these with your own images
	<link rel="shortcut icon" href="images/favicon.ico">
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
	-->

	<link rel="alternate" type="application/rss+xml" title="" href="/feed.xml">
</head>

<body>
	<nav class="navbar navbar-default visible-xs" role="navigation">
		<!-- Brand and toggle get grouped for better mobile display -->
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			
			<a type="button" class="navbar-toggle nav-link" href="http://github.com/liujingyu">
				<i class="fa fa-github"></i>
			</a>
			
			
			
			<a type="button" class="navbar-toggle nav-link" href="mailto:jingyu525@gmail.com">
				<i class="fa fa-envelope"></i>
			</a>
			
			<a class="navbar-brand" href="/">
                <img src="/assets/media/dragon.jpeg" class="img-circle" />
				JY
			</a>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
				<li class="active"><a href="/">Home</a></li>
				<li><a href="/categories.html">Categories</a></li>
				<li><a href="/tags.html">Tags</a></li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</nav>

	<!-- nav-menu-dropdown -->
	<div class="btn-group hidden-xs" id="nav-menu">
		<button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
			<i class="fa fa-bars"></i>
		</button>
		<ul class="dropdown-menu" role="menu">
			<li><a href="/"><i class="fa fa-home"></i>Home</a></li>
			<li><a href="/categories.html"><i class="fa fa-folder"></i>Categories</a></li>
			<li><a href="/tags.html"><i class="fa fa-tags"></i>Tags</a></li>
			<li class="divider"></li>
			<li><a href="#"><i class="fa fa-arrow-up"></i>Top of Page</a></li>
		</ul>
	</div>

	<div class="col-sm-3 sidebar hidden-xs" style="background: url(/assets/media/sky.png) no-repeat !important;">
		<!-- sidebar.html -->
<header class="sidebar-header" role="banner">
	<a href="/">
        <img src="/assets/media/dragon.jpeg" class="img-circle"  height="150" width="150" />
	</a>
	<h3 class="title">
        <a href="/">JY</a>
    </h3>
</header>


<div id="bio" class="text-center">
	目前就职于小猪短租
</div>


<div id="contact-list" class="text-center">
	<ul class="list-unstyled list-inline">
		
		<li>
			<a class="btn btn-default btn-sm" href="https://github.com/liujingyu">
				<i class="fa fa-github-alt fa-lg"></i>
			</a>
		</li>
		
		
		<li>
			<a class="btn btn-default btn-sm" href="mailto:jingyu525@gmail.com">
				<i class="fa fa-envelope fa-lg"></i>
			</a>
		</li>
		
		<li>
			<a class="btn btn-default btn-sm" href="/feed.xml">
				<i class="fa fa-rss fa-lg"></i>
			</a>
		</li>
	</ul>
	<ul class="list-unstyled list-inline">
		<li>
            <a class="btn btn-default btn-sm" href="/about">
                关于
			</a>
		</li>
		<li>
            <a class="btn btn-default btn-sm" href="/elasticsearch">
                elasticsearch
			</a>
		</li>
		<li>
            <a class="btn btn-default btn-sm" href="/open-source">
                开源项目
			</a>
		</li>
	</ul>
</div>
<!-- sidebar.html end -->

	</div>

	<div class="col-sm-9 col-sm-offset-3">
		<div class="page-header">
  <h1>JY </h1>
</div>



<article class="home">

  <span class="post-date">
    
    February
    24th,
    
    2020
  </span>

  <h2>
    <a href="/linux%20load/2020/02/24/high-machine-load.html">机器高负载排查</a>
  </h2>

  <div>
    
    <h3 id="可以查询机器负载的命令">可以查询机器负载的命令</h3>

<p>三个命令：<code class="highlighter-rouge">w</code>, <code class="highlighter-rouge">uptime</code>, <code class="highlighter-rouge">top</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[www@cloud-test-env79 ~]$ w
 16:36:59 up  2:23,  1 user,  load average: 19.02, 18.69, 18.31
 USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
 www      pts/1    10.3.2.67        16:36    2.00s  0.00s  0.00s w


[www@cloud-test-env79 ~]$ uptime
 16:40:56 up  2:27,  1 user,  load average: 18.40, 18.24, 18.20


top - 16:41:09 up  2:27,  1 user,  load average: 18.25, 18.21, 18.19

</code></pre></div></div>

<h3 id="什么是机器负载load-平均负载-load-average">什么是机器负载Load? 平均负载 Load Average</h3>

<p>Load 就是对计算机干活多少的度量（WikiPedia：the system Load is a measure of the amount of work that a compute system is doing）简单的说是进程队列的长度。Load Average 就是一段时间（1分钟、5分钟、15分钟）内平均Load</p>

<h3 id="如何判断over-load">如何判断Over Load</h3>

<p>一般来说，根据CPU数量判断，如果平均负载始终再<code class="highlighter-rouge">1.2</code>以下，机器是<code class="highlighter-rouge">2</code>颗 <code class="highlighter-rouge">CPU</code>。那么基本不会出现CPU不够用的情况。
也就是Load平均要小于CPU的数量，一般会根据15分钟那个load的平均值。</p>

<p>一般而言，服务器的合理负载是<code class="highlighter-rouge">CPU核数*2</code>。也就是说对于8核的CPU，负载在16以内表明机器运行很稳定流畅。如果负载超过16了，就说明服务器的运行有一定的压力了。</p>

<h3 id="我们如何排查机器高负载">我们如何排查机器高负载</h3>

<h4 id="vmstat是virtual-meomory-statistics虚拟内存统计的缩写可实时动态监视操作系统的虚拟内存进程cpu活动">vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可实时动态监视操作系统的虚拟内存、进程、CPU活动。</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 18  0  16640 221116      0 1426276    0    1   133   195 2053  591 78 14  7  0  0
 23  0  16640 245128      0 1426836    0    0     0    66 4208 1059 86 14  0  0  0
 19  0  16640 227160      0 1427340    0    0     0    37 4144 1040 85 15  0  0  0
 16  0  16640 259528      0 1428076    0    0     0   329 4090 1001 85 15  0  0  0
 13  0  16640 261376      0 1428476    0    0     0     0 4087 1042 84 16  0  0  0
</code></pre></div></div>

<p>字段说明</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Procs（进程）:
    r: 运行队列中进程数量 (如果长期大于1，说明cpu不足，需要增加cpu。)
    b: 等待IO的进程数量 (比如正在等待I/O、或者内存交换等。)
    Memory（内存）:
    swpd: 使用虚拟内存大小
    free: 可用内存大小
    buff: 用作缓冲的内存大小
    cache: 用作缓存的内存大小
Swap:
    si: 每秒从交换区写到内存的大小
    so: 每秒写入交换区的内存大小
IO：（现在的Linux版本块的大小为1024bytes）
    bi: 每秒读取的块数
    bo: 每秒写入的块数
system：
    in: 每秒中断数，包括时钟中断
    cs: 每秒上下文切换数
CPU（以百分比表示）
    us: 用户进程执行时间(user time)
    sy: 系统进程执行时间(system time)
    id: 空闲时间(包括IO等待时间)
    wa: 等待IO时间
</code></pre></div></div>

<h4 id="iostat-查看io负载">iostat 查看IO负载</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[www@cloud-test-env79 ~]$ iostat 1 1
Linux 3.10.0-957.21.3.el7.x86_64 (cloud-test-env79)     02/24/2020      _x86_64_        (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          79.06    0.00   14.45    0.04    0.00    6.46

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               1.29        24.13         4.30     255262      45469
sdb              22.42       216.43       362.11    2289445    3830471
dm-0              0.87        21.18         1.65     224015      17504
dm-1              0.74         0.58         2.45       6156      25904
</code></pre></div></div>

<p>avg-cpu: 总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值</p>
<ul>
  <li>%user: 在用户级别运行所使用的CPU的百分比.</li>
  <li>%nice: nice操作所使用的CPU的百分比.</li>
  <li>%sys: 在系统级别(kernel)运行所使用CPU的百分比.</li>
  <li>%iowait: CPU等待硬件I/O时,所占用CPU百分比.</li>
  <li>%idle: CPU空闲时间的百分比.</li>
</ul>

<p>Device段:各磁盘设备的IO统计信息</p>
<ul>
  <li>tps: 每秒钟发送到的I/O请求数.</li>
  <li>Blk_read /s: 每秒读取的block数.</li>
  <li>Blk_wrtn/s: 每秒写入的block数.</li>
  <li>Blk_read: 读入的block总数.</li>
  <li>Blk_wrtn: 写入的block总数.</li>
</ul>

<h4 id="sar-找出系统瓶颈的利器">sar 找出系统瓶颈的利器</h4>

<p>查看CPU使用率 <code class="highlighter-rouge">sar -u</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
02:13:57 PM       LINUX RESTART

02:20:01 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
02:30:01 PM     all     38.17      0.00      6.64      0.02      0.00     55.17
02:40:02 PM     all     84.96      0.00     15.01      0.00      0.00      0.03
02:50:01 PM     all     84.93      0.00     15.03      0.00      0.00      0.04
03:00:01 PM     all     84.69      0.00     15.27      0.00      0.00      0.04
03:10:01 PM     all     84.62      0.00     15.35      0.00      0.00      0.04
03:20:01 PM     all     83.92      0.00     16.05      0.00      0.00      0.03
03:30:01 PM     all     84.98      0.00     14.98      0.00      0.00      0.04
03:40:02 PM     all     84.88      0.00     15.07      0.00      0.00      0.05
03:50:01 PM     all     84.63      0.00     15.34      0.00      0.00      0.03
04:00:02 PM     all     84.86      0.00     15.09      0.00      0.00      0.04
04:10:02 PM     all     84.56      0.00     15.41      0.00      0.00      0.04
04:20:01 PM     all     83.73      0.00     16.24      0.00      0.00      0.03
04:30:02 PM     all     83.97      0.00     15.99      0.00      0.00      0.04
04:40:01 PM     all     83.84      0.00     16.13      0.00      0.00      0.03
04:50:02 PM     all     84.77      0.00     15.22      0.00      0.00      0.01
Average:        all     81.44      0.00     14.86      0.00      0.00      3.71

</code></pre></div></div>
<p>可以看到这台机器使用了虚拟化技术，有相应的时间消耗； 各列的指标分别是:</p>

<ul>
  <li>%user 用户模式下消耗的CPU时间的比例；</li>
  <li>%nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li>
  <li>%system 系统模式下消耗的CPU时间的比例；</li>
  <li>%iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例；</li>
  <li>%steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；</li>
  <li>%idle CPU空闲时间比例；</li>
</ul>

<p>查看平均负载(sar -q)</p>

<p>指定-q后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等；与其它命令相比，它能查看各项指标随时间变化的情况；</p>

<ul>
  <li>runq-sz：运行队列的长度（等待运行的进程数）</li>
  <li>plist-sz：进程列表中进程（processes）和线程（threads）的数量</li>
  <li>ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载</li>
  <li>ldavg-15：过去15分钟的系统平均负载</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>02:13:57 PM       LINUX RESTART

02:20:01 PM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked
02:30:01 PM        23       215     18.70     10.79      4.67         0
02:40:02 PM        15       204     18.32     17.53     11.33         0
02:50:01 PM        17       202     17.31     17.35     14.18         0
03:00:01 PM         5       202     17.28     17.45     15.75         0
03:10:01 PM        15       201     16.86     17.47     16.60         0
03:20:01 PM        18       201     17.40     17.73     17.32         0
03:30:01 PM        17       202     17.98     17.60     17.43         0
03:40:02 PM        18       199     16.85     17.40     17.45         0
03:50:01 PM        19       205     18.94     18.30     17.80         0
04:00:02 PM        18       204     17.58     17.65     17.68         0
04:10:02 PM        19       208     18.68     18.29     18.00         1
04:20:01 PM        19       200     17.22     18.03     18.09         0
04:30:02 PM        21       211     18.28     17.87     17.96         0
04:40:01 PM        16       205     17.54     18.13     18.17         0
04:50:02 PM        17       202     17.72     17.79     18.01         0
Average:           17       204     17.78     17.29     16.03         0
</code></pre></div></div>

<p>查看内存使用状况(sar -r)</p>

<p>字段注解：</p>
<ul>
  <li>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>
  <li>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>
  <li>%memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>
  <li>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</li>
  <li>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>
  <li>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>02:13:57 PM       LINUX RESTART

02:20:01 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
02:30:01 PM    449916   3430448     88.41       948    925236   3204692     53.61   1564160    727752     74388
02:40:02 PM    250496   3629868     93.54        76    642292   3434756     57.46   1918776    577624      2896
02:50:01 PM    217472   3662892     94.40        76    646180   3468536     58.03   1874572    655268      1220
03:00:01 PM    200560   3679804     94.83        76    645484   3483892     58.28   1869832    677108      1400
03:10:01 PM    232804   3647560     94.00        36    687240   3407608     57.01   1824896    690028      1812
03:20:01 PM    237268   3643096     93.89         0    658572   3502412     58.59   1764740    801092      2316
03:30:01 PM    285796   3594568     92.63         0    674780   3493840     58.45   1752620    832220      2832
03:40:02 PM    297988   3582376     92.32         0    744884   3409472     57.04   1748868    820916      1592
03:50:01 PM    193656   3686708     95.01         0    929264   3597268     60.18   1823876   1070348      3652
04:00:02 PM    168556   3711808     95.66         0    944632   3562620     59.60   1847804   1070788       856
04:10:02 PM    170684   3709680     95.60         0    964628   3529120     59.04   1829056   1059360      2620
04:20:01 PM    251432   3628932     93.52         0    911876   3475648     58.15   1772392   1034332      2792
04:30:02 PM    276664   3603700     92.87         0    929752   3433156     57.43   1746496   1030228      3652
04:40:01 PM    353412   3526952     90.89         0    848160   3414616     57.12   1687536    993700       944
04:50:02 PM    244372   3635992     93.70         0    914408   3458112     57.85   1802704    986708       620
Average:       255405   3624959     93.42        81    804493   3458383     57.86   1788555    868498      6906

</code></pre></div></div>

<p>查看页面交换发生状况(sar -W)</p>

<p>页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用这个命令来确认是否发生了大量的交换；</p>

<ul>
  <li>pswpin/s：每秒系统换入的交换页面（swap page）数量</li>
  <li>pswpout/s：每秒系统换出的交换页面（swap page）数量</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>02:13:57 PM       LINUX RESTART

02:20:01 PM  pswpin/s pswpout/s
02:30:01 PM      0.00      0.00
02:40:02 PM      0.00      0.03
02:50:01 PM      0.04      0.65
03:00:01 PM      0.08      0.83
03:10:01 PM      0.09      0.20
03:20:01 PM      0.25      0.45
03:30:01 PM      0.12      0.39
03:40:02 PM      0.07      0.00
03:50:01 PM      0.24      0.84
04:00:02 PM      0.04      0.30
04:10:02 PM      0.16      0.74
04:20:01 PM      0.31      1.20
04:30:02 PM      0.08      0.84
04:40:01 PM      0.33      2.06
04:50:02 PM      0.07      0.00
Average:         0.13      0.57
</code></pre></div></div>

<p>要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来；</p>

<ul>
  <li>怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看</li>
  <li>怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看</li>
  <li>怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</li>
</ul>


    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    February
    20th,
    
    2020
  </span>

  <h2>
    <a href="/c%20protocol/2020/02/20/learn-http.html">HTTP</a>
  </h2>

  <div>
    
    <h2 id="http是什么">HTTP是什么</h2>

<p>HTTP是Hypertext Transfer Protocol 的缩写，超文本传输协议</p>

<h2 id="为什么学习http">为什么学习HTTP</h2>

<p>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论, 底层协议正是使用的Http协议。做为后端开发的同学，有必要了解底层的HTTP协议内容及实现逻辑，有利于我们清楚整个具体过程到底发生了什么。</p>

<h2 id="如何学习http">如何学习HTTP</h2>

<h3 id="client--server-交互场景">client &amp; server 交互场景</h3>

<p><img src="/assets/media/20180826161800456.png" alt="client&amp;server" /></p>

<h3 id="http-报文结构">HTTP 报文结构</h3>

<p><img src="/assets/media/20180826205639881.png" alt="http message structure" /></p>

<p><img src="/assets/media/20180826154938556.png" alt="request example" /></p>

<p><img src="/assets/media/20180826155011558.png" alt="response example" /></p>

<h3 id="经典开源的http-server项目">经典开源的HTTP Server项目</h3>

<ul>
  <li>
    <p><a href="https://github.com/EZLippi/Tinyhttpd">源码Tinyhttpd</a></p>
  </li>
  <li>
    <p><img src="/assets/media/20160413230616951.png" alt="流程图" /></p>
  </li>
  <li>
    <p>阅读代码顺序 <code class="highlighter-rouge">main -&gt; startup -&gt; accept_request -&gt; execute_cgi</code></p>
  </li>
  <li>每个函数作用
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>accept_request:  处理从套接字上监听到的一个 HTTP 请求，在这里可以很大一部分地体现服务器处理请求流程。
bad_request: 返回给客户端这是个错误请求，HTTP 状态吗 400 BAD REQUEST.
cat: 读取服务器上某个文件写到 socket 套接字。
cannot_execute: 主要处理发生在执行 cgi 程序时出现的错误。
error_die: 把错误信息写到 perror 并退出。
execute_cgi: 运行 cgi 程序的处理，也是个主要函数。
get_line: 读取套接字的一行，把回车换行等情况都统一为换行符结束。
headers: 把 HTTP 响应的头部写到套接字。
not_found: 主要处理找不到请求的文件时的情况。
sever_file: 调用 cat 把服务器文件返回给浏览器。
startup: 初始化 httpd 服务，包括建立套接字，绑定端口，进行监听等。
unimplemented: 返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。
</code></pre></div>    </div>
  </li>
  <li>cgi页面请求响应处理的核心函数—— <code class="highlighter-rouge">execute_cgi()</code></li>
</ul>

<p><img src="/assets/media/2018050721251980.png" alt="Pipe state" /></p>

<ul>
  <li>
    <p>Docker C 环境, 调试PHP源码用的Docker环境, 大家可以试试 <a href="https://github.com/liujingyu/docker-debug-php-src">docker-debug-php-src</a></p>
  </li>
  <li>
    <p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">GDB 工具参考</a></p>
  </li>
  <li>
    <p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程</a></p>
  </li>
</ul>

<h2 id="参考链接">参考链接</h2>
<ul>
  <li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a></li>
  <li><a href="https://blog.csdn.net/u013644957/article/details/51147723">Tinyhttpd for Ubuntu 14.04 中文详细注释版</a></li>
  <li><a href="https://blog.csdn.net/thisinnocence/article/details/82081887">HTTP1.1 基础: 请求和响应的消息交互细节</a></li>
  <li><a href="https://datatracker.ietf.org/doc/rfc2616/">RFC文档</a>
    <ul>
      <li>摘要</li>
      <li>The Hypertext Transfer Protocol (HTTP) is an application-level
 protocol for distributed, collaborative, hypermedia information
 systems. It is a generic, stateless, protocol which can be used for
 many tasks beyond its use for hypertext, such as name servers and
 distributed object management systems, through extension of its
 request methods, error codes and headers [47]. A feature of HTTP is
 the typing and negotiation of data representation, allowing systems
 to be built independently of the data being transferred.</li>
    </ul>

    <p>HTTP has been in use by the World-Wide Web global information
 initiative since 1990. This specification defines the protocol
 referred to as “HTTP/1.1”, and is an update to RFC 2068 [33].</p>
  </li>
</ul>


    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    February
    10th,
    
    2020
  </span>

  <h2>
    <a href="/c/2020/02/10/c-demo.html">C 语言 Demo示例学习</a>
  </h2>

  <div>
    
    <h3 id="函数指针">函数指针</h3>

<p>函数指针是指向函数的指针变量。</p>

<p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p>

<p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p>

<p>函数指针变量的声明：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型
</code></pre></div></div>

<p>实例</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int max(int x, int y)
{
    return x &gt; y ? x : y;
}

int main(void)
{
    /* p 是函数指针 */
    int (* p)(int, int) = &amp; max; // &amp;可以省略
    int a, b, c, d;

    printf("请输入三个数字:");
    scanf("%d %d %d", &amp; a, &amp; b, &amp; c);

    /* 与直接调用函数等价，d = max(max(a, b), c) */
    d = p(p(a, b), c);

    printf("最大的数字是: %d\n", d);

    return 0;
}
</code></pre></div></div>

<p>编译执行，输出结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>请输入三个数字:1 2 3
最大的数字是: 3
</code></pre></div></div>

<h3 id="回调函数">回调函数</h3>

<p>函数指针作为某个函数的参数</p>

<p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>

<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>

<h3 id="c-typedef">C typedef</h3>

<p>C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef unsigned char BYTE;
</code></pre></div></div>
<p>在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BYTE  b1, b2;
</code></pre></div></div>
<p>按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef unsigned char byte;
</code></pre></div></div>

<p>示例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;

int main( )
{
   Book book;

   strcpy( book.title, "C 教程");
   strcpy( book.author, "Runoob");
   strcpy( book.subject, "编程语言");
   book.book_id = 12345;

   printf( "书标题 : %s\n", book.title);
   printf( "书作者 : %s\n", book.author);
   printf( "书类目 : %s\n", book.subject);
   printf( "书 ID : %d\n", book.book_id);

   return 0;
}
</code></pre></div></div>

<h3 id="typedef-vs-define">typedef vs #define</h3>

<p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p>
<ul>
  <li>typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li>
  <li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。</li>
</ul>

<p>下面是 #define 的最简单的用法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

#define TRUE  1
#define FALSE 0

int main( )
{
   printf( "TRUE 的值: %d\n", TRUE);
   printf( "FALSE 的值: %d\n", FALSE);

   return 0;
}
</code></pre></div></div>

<h3 id="枚举类型vs常量">枚举类型vs常量</h3>

<p>枚举常量是另外一种类型的常量。枚举是一个常量整型值的列表。</p>

<h3 id="c-enum枚举">C enum(枚举)</h3>

<p>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。</p>

<p>枚举语法定义格式为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum　枚举名　{枚举元素1,枚举元素2,……};
</code></pre></div></div>

<p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7
</code></pre></div></div>

<p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
</code></pre></div></div>

<h3 id="c-命令行参数">C 命令行参数</h3>

<p>执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</p>

<p>命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main( int argc, char *argv[] )
{
   if( argc == 2 )
   {
      printf("The argument supplied is %s\n", argv[1]);
   }
   else if( argc &gt; 2 )
   {
      printf("Too many arguments supplied.\n");
   }
   else
   {
      printf("One argument expected.\n");
   }
}
</code></pre></div></div>
<p>使用一个参数，编译并执行上面的代码，它会产生下列结果：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$./a.out testing
The argument supplied is testing
</code></pre></div></div>

<h3 id="c-内存管理">C 内存管理</h3>

<p><code class="highlighter-rouge">void *calloc(int num, int size);</code>
在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 <code class="highlighter-rouge">num*size</code> 个字节长度的内存空间，并且每个字节的值都是0。</p>

<p><code class="highlighter-rouge">void free(void *address);</code>
该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</p>

<p><code class="highlighter-rouge">void *malloc(int num);</code>
在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</p>

<p><code class="highlighter-rouge">void *realloc(void *address, int newsize);</code>
该函数重新分配内存，把内存扩展到 newsize。</p>

<p>注意：void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>

<h4 id="动态分配内存">动态分配内存</h4>

<p>编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char name[100];
</code></pre></div></div>

<p>但是，如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
   char name[100];
   char *description;

   strcpy(name, "Zara Ali");

   /* 动态分配内存 */
   description = (char *)malloc( 200 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student in class 10th");
   }
   printf("Name = %s\n", name );
   printf("Description: %s\n", description );
}
</code></pre></div></div>

<p>上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calloc(200, sizeof(char));
</code></pre></div></div>

<p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。</p>

<h4 id="重新调整内存的大小和释放内存">重新调整内存的大小和释放内存</h4>

<p>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 free() 来释放内存。</p>

<p>或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
   char name[100];
   char *description;

   strcpy(name, "Zara Ali");

   /* 动态分配内存 */
   description = (char *)malloc( 30 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student.");
   }
   /* 假设您想要存储更大的描述信息 */
   description = (char *) realloc( description, 100 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcat( description, "She is in class 10th");
   }

   printf("Name = %s\n", name );
   printf("Description: %s\n", description );

   /* 使用 free() 函数释放内存 */
   free(description);
}
</code></pre></div></div>

<h3 id="c-预处理器">C 预处理器</h3>

<p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>

<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>指令	描述
#define	定义宏
#include	包含一个源代码文件
#undef	取消已定义的宏
#ifdef	如果宏已经定义，则返回真
#ifndef	如果宏没有定义，则返回真
#if	如果给定条件为真，则编译下面代码
#else	#if 的替代方案
#elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
#endif	结束一个 #if……#else 条件编译块
#error	当遇到标准错误时，输出错误消息
#pragma	使用标准化方法，向编译器发布特殊的命令到编译器中
</code></pre></div></div>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    February
    8th,
    
    2020
  </span>

  <h2>
    <a href="/plan/2020/02/08/work-plan.html">职业规划</a>
  </h2>

  <div>
    
    <p>前几天，听PM圈子的老师分享关于项目经理的职业规划，顺便分享了职业规划的大致框架。</p>

<p><img src="assets/media/职业生涯规划.png" alt="职业规划" /></p>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    January
    19th,
    
    2020
  </span>

  <h2>
    <a href="/logical/2020/01/19/quantitative-theory.html">量化理论</a>
  </h2>

  <div>
    
    <p>演绎论证,它们的分支命题不是复合命题, 并且其有效性或无效性取决于这些非复合命题的内在逻辑结构。</p>

<p>单称命题,介绍了个体变元符号x,个体常项符号(小写字母从a到u)以及表示属性的符号(大写字母)。介绍了命题函项概念: 个含有一个个体变元的表达式,当以一个个体常元代入个体変元时,它就変成一个陈述。因此,通过列举程序,可以从一个命题函项得到一个命题。</p>

<p>如何用概括的方法,也就是通过使用“每个”、“没有”有些”等量词,从命题函项得到命题。介绍了全称量词(x),其含义是给定任何一个x”,以及存在量词(ヨx),其含义是“至少存在一个如此这般的x”。还用对当方阵表明了全称量化和存在量化之间的关系。</p>

<p>怎样用命题函项和量词正确地符号化以下四种主要命题: A:全称肯定命题E:全称否定命题I:特称肯定命题O:特称否定命题还对A、E、I、O四种命题之间关系的现代解释进行了说明。</p>

<p>通过增加以下四个附加规则,扩展了推论规则表: 全称列举,UI 全称概括,UG 存在列举,E 存在概括,EG并且说明了怎样用这四个和前面已提出的19条推论规则,构造演绎论证有效性的形式证明,这种证明涉及非复合命题的内部结构。</p>

<p>如何设计含有一个、两个或三个个体的模型或可能域以及在该可能域中改写论证的各分支命题,由此用逻辑类推的反驳方法来证明一个涉及量词的论证的无效性。如果我们能展示这样一个可能域,即它至少含有一个使该论证的所有前提在域中为真而结论在其中为假的个体,那么,我们就证明了这个涉及量词的论证无效</p>

<p>怎样对非三段论论证进行符号化和评价。这些论证含有些不能划归为A、E、I、O命题或单称命题的命题。鉴于除外命题和其他一些命题的复杂性,必须先理解它们的逻辑含义,然后才能用命题函项和量词进行准确的翻译。</p>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    January
    17th,
    
    2020
  </span>

  <h2>
    <a href="/logical/2020/01/17/syllogism.html">直言三段论</a>
  </h2>

  <div>
    
    <p>标准式直言三段论:
组成成分、形式、有效性和制约其正确使用的规则。</p>

<p>三段论大项、小项和中项的定义:</p>

<p>大项:结论的谓项</p>

<p>小项:结论的主项</p>

<p>中项:两个前提中都出现, 但结论中不出现的第三个项</p>

<p>继而又分别定义了大前提和小前提,包含大项的前提叫做大前提,包含小项的前提叫做小前提。</p>

<p>如果几个命题出现的次序正好是:大前提在第一位、小前提在第二位、结论在最后,我们就把这样的三段论指定为标准式的。</p>

<p>三段论的式与格是如何确定的。
段论的式由识别三个命题类型的字母来确定,即A、E、1、O中的三个。总共有64个不同式。
段论的格由中项在前提中的不同位置来确定。</p>

<p>对四个可能的格描述并定义如下:</p>

<p><strong>第一格</strong>:中项在大前提中做主项、在小前提中做谓项。 模式为:M-P,S-M,所以S-P。</p>

<p><strong>第二格</strong>:中项在两个前提中都儆谓项。 模式为:P-M,S-M,所以S-P</p>

<p><strong>第三格</strong>:中项在两个前提中都做主项。 模式为:M一P,M-S,所以S-P。</p>

<p><strong>第四格</strong>:中项在大前提中做谓项、在小前提中做主项。 模式为:P-M,M-S,所以S-P。</p>

<p>标准式三段论的式与格如何共同地确定其逻辑形式。由于64个式每一个都有四个格,所以共有256个标准式的直言三段论,但其中只有一小部分是有效式。</p>

<p>标准式三段论的六条基本规则,同时定义了违反各条规则所造成的谬误。</p>

<p><strong>规则1</strong>一个有效的标准式直言三段论必须仅仅包含三个项,在整个论证中,每一个项都须在相同的意义上使用。</p>

<p>违反本规则所犯的错误:四项谬误。</p>

<p><strong>规则2</strong>在一个有效的标准式直言三段论中,中项必须至少在一个前提中周延。</p>

<p>违反本规则所犯的错误:中项不周延谬误。</p>

<p><strong>规则3</strong>在一个有效的标准式直言三段论中,在结论中周延的项在前提中也必须周延。</p>

<p>违反本规则所犯的错误:大项不当周延谬误,或者小项不当周延谬误</p>

<p><strong>规则4</strong>任何有两个否定前提的标准式三段论都不是有效的。</p>

<p>违反本规则所犯的错误:排斥前提谬误。</p>

<p><strong>规则5</strong>如果一个标准式三段论有一个前提是否定的,那么结论必须是否定的。</p>

<p>违反本规则所犯的错误:从否定推肯定谬误。</p>

<p><strong>规则6</strong>一个有效的标准式直言三段论,如果结论为特称命题,那么其前提不能都是全称的。</p>

<p>违反本规则所犯的错误:存在谬误。</p>

<p>标准式直言三段论的15个有效形式的说明,识别它们的格与式,并说明了它们传统的拉丁名称:
AAA-1( Barbara)、EAE-1( parent)、AII1(Dari)、EIO-1(Fe rio)、AEE-2( Camestres)、EAE-2( Cesare)、AOO2( Baroko)、EIO2( Festino)、AII-3( Datisi)、IAI-3( Disamis)、EIO-3( Ferison)、OAO3 ( Bokardo)、AEE-4( amenes)、IAI-4( Dimaris)、EIO-4( Fresison)。</p>

<p>15个有效形式的演绎推导,通过排除法程序,证明了只有15个形式是完全遵守三段论的六条基本规则的。</p>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    January
    17th,
    
    2020
  </span>

  <h2>
    <a href="/logical/2020/01/17/logical-fallacy.html">谬误</a>
  </h2>

  <div>
    
    <h3 id="什么是谬误">什么是谬误</h3>

<p>谬误是那种看起来正确但经过考察而证明并非如此的论证。</p>

<p>谬误三大类非形式谬误：相干谬误、预设谬误和含混谬误。</p>

<h3 id="相干谬误">相干谬误</h3>

<p>相干谬误在这类谬误中,错误论证依赖于看起来可能与结论相关但事实上无关的前提。我们分七种相干谬误来解释这类推理错误。</p>

<p>R1.诉诸无知论证:当以一命题没有被证明是假的为理由来论证该命题是真的,或当论证一命题是假的因为它没有被证明是真的。</p>

<p>R2.诉诸不当权威:一个论证的前提诉诸某方或多方判断,而它或它们却不能合法地声称对手头问题具有权威。</p>

<p>R3.人身攻击论证:攻击不是针对所做的主张或针对论证的优点, 而是针对对手本身。
人身攻击论证有两种形式。当攻击直接针对人,以寻求诋毁和侮辱他们时,就称做“诽谤性人身攻击论证”。当攻击间接地对准人,暗示他们坚持他们的观点主要是因为他们的特殊环境或利益时,就称做“背景性人身攻击论证”。</p>

<p>R4.诉诸情感:细心推理被激起狂热或情感来支持预先结论的精心策划所取代。</p>

<p>R5.诉诸同情:细心推理被激起听者同情来达到说者所关注目标的精心策划所取代。</p>

<p>R6.诉诸武力:为了得到对某些结论的承诺,细心推理被直接或含沙射影的威胁所取代。</p>

<p>R7.不相于结论:前提不得要领,声称支持一个结论而事实上却支持或证实另一个结论。</p>

<h3 id="预设谬误">预设谬误</h3>

<p>预设谬误在这类谬误中,错误论证源于依赖于某些被假定为真的命题,而这些命题实际上是假的、可疑的或没有得到证明的。我们分五种预设谬误来解释这类推理错误。</p>

<p>P1.复杂问语:以问句预设了某些假设为真的方式来询向问题。</p>

<p>P2.虚假原因:把一个东西当做一个事物的原因而它实际上并不是那个事物的原因,或更一般地说,在以因果关系为基础的推理中犯错</p>

<p>P3.丐题:在某个论证前提中假定了结论要寻求确证的东西。</p>

<p>P4.偶然:把某个概括运用于它不能适当管辖的个别情况P5.逆偶然:粗心大意地从单个情况转移到一个无辦护余地的广泛概括。</p>

<h3 id="含混谬误">含混谬误</h3>

<p>含混谬误在这类谬误中,错误论证的形成方式是,它依赖于词或短语从在前提中的用法到在结论中的用法的意义变化。我们分五种含混谬误来解释这类推理错误。</p>

<p>A1.歧义:在论证的明确表述中,有意或无意地使用同一个词或短语的两个或更多意义。</p>

<p>A2.双关:因为陈述中的词或短语结合得松散或笨拙,论证中的这个陈述具有多于一个合理意义。</p>

<p>A3.重读:意义的变化作为对论证的词或短语的强调改变的结果而源于该论证之内。</p>

<p>A4.合成:(a)错误地从部分性质到整体性质进行推理,(b)或者, 错误地从某汇集的个别分子性质到整个汇集的性质进行推理。</p>

<p>A5.分解:(a)错误地从整体性质到它的一个部分的性质进行推理, (b)或者,错误地从某些实体汇集的某个全体性质到该汇集的个别实体性质进行推理。</p>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    January
    17th,
    
    2020
  </span>

  <h2>
    <a href="/logical/2020/01/17/language-usage.html">语言的用法</a>
  </h2>

  <div>
    
    <p>语言的多种用法和形式,以及可能由于没有认识到这些复杂性而引起的错解和滥用。</p>

<p>语言的三种基本功能: <strong>信息性功能、表达性功能和指令性功能</strong>。</p>

<p>一个给定语段可能行使的多种功能的方式:同时行使两种甚或所有三种功能。</p>

<p>标准语法形式的句子,即<strong>陈述句、疑问句、祈使句和感叹句</strong>,并不总是行使与其名称相关的功能。陈述句可以用做指令性的或者表达性的功能;疑问句可以具有信息性的或指令性的功能,等等。语法形式不决定语言功能。</p>

<p><strong>信念歧见与态度歧见</strong>。冲突双方可以既在事实是什么上致也在对事实的态度上一致,或者在两方面都对立。他们可能在事实上致,而在对事实的态度上对立。他们还可能在事实是什么上对立,但在对他们所相信的事实的态度上却致。要解决歧见问题,了解其真正本性是极其重要的。</p>


    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    January
    17th,
    
    2020
  </span>

  <h2>
    <a href="/logical/2020/01/17/definition.html">定义</a>
  </h2>

  <div>
    
    <p>解释词项的意义就是给出它的定义。</p>

<p>三种论争:</p>

<p>1.明显的实质争论,其中没有语词歧义,而且论争双方的确在态度上或信念上对立。</p>

<p>2.纯粹言辞之争,其中出现语词歧义,但根本没有实质歧见。</p>

<p>3.表面上是言辞的但实际上是实质的论争,其中既存在语词歧义, 也存在论争双方在态度上或在信念上的歧见。</p>

<p>定义总是符号的定义,并且引进了术语被定义项(被定义的符号)和定义项(用来解释被定义项意义的符号)。</p>

<p>还在五种定义及其基本用法中进行了区分:</p>

<p>1.规定定义,把一个意义指派给某个符号。规定定义不是报道,因而既不真也不假;它是运用被定义项来意指定义项指谓事物的建议、解决、请求或工具。</p>

<p>2.词典定义,它报道被定义项已经具有的意义,因而它可以或对或错。</p>

<p>3.精确定义,它超出了平常用法,用于消除与临界状况有关的麻烦的不确定性。其被定义项有一个现存的意义,但这个意义是模糊的;增添什么可以达至精确性,部分上是个规定问题。</p>

<p>4.理论定义,它寻求对它的适用对象精确表述一个理论上足够或科学上有用的描述。</p>

<p>5.说服定义,它运用表达性语言而不是信息性语言来寻求影响态度或激发情感。</p>

<p>在这五种定义中,前两种(规定定义和词典定义)主要用于消除歧义;第三种(精确定义)主要用于降低模糊性;第四种(理论定义)用于促进理论理解;而第五种(说服定义)用于影响行为。</p>

<p>普遍词项指谓其可以正确适用的多个对象。这些对象的汇集构成该词项的外延。说明了为词项外延中的所有对象并且仅为那些对象所共有的属性集就是该词项的内涵。词项的内涵决定其外延,但外延却不能决定内涵;因此,几个词项可以具有不同内涵而外延却相同;但外延不同的词项却不可能具有相同内涵。</p>

<p>怎样利用普遍词项的外延来构造外延定义;外延定义有几种类型,其局限性也被揭示出来:</p>

<p>1.列举定义,即在定义中列出或给出词项指谓对象的范例。</p>

<p>2.实指定义,在定义时,我们用手指出或以姿势标明被定义项的外延。</p>

<p>3.准实指定义,在定义中,姿势或手指的指示伴有一些其意义被认为是已为人所知的描述短语。</p>

<p>怎样利用普遍词项的内涵来构建内涵定义;内涵定义也有几种类型,其局限性也被揭示出来:</p>

<p>1.同义定义,在定义中提供另一个其意义已为人所知的词,这个词与被定义的词具有相同意义</p>

<p>2.操作定义,它表明词项正确运用于一个给定场合,当且仅当,在该场合下特有的操作行为产生特有结果。</p>

<p>3.属加种差定义,首先要找出一个属,被定义项所指代的种是该属的一个子类;然后找出属性(或种差),即把该种的分子与属的所有其他种的分子区分开来的那种属性。</p>

<p>内涵定义的方法可以用于构建五种定义的任何一种: 规定定义、词典定义、精确定义、理论定义和说服定义。</p>

<p>传统的属加种差定义的五条规则:</p>

<p>1.定义应当揭示种的本质属性。</p>

<p>2.定义不能循环。</p>

<p>3.定义既不能过宽又不能过窄。</p>

<p>4.定义不能用岐义的、晦涩的或比喻的语言来表述.定义在可以用肯定的地方就不应当用否定定义。</p>

    
  </div>

</article>


<article class="home">

  <span class="post-date">
    
    January
    17th,
    
    2020
  </span>

  <h2>
    <a href="/logical/2020/01/17/blunt-proposition.html">直言命题</a>
  </h2>

  <div>
    
    <p>本章介绍并讨论的是古典逻辑即亚里士多德型逻辑的基本构件,也是演绎逻辑的基本构件。</p>

<p>传统逻辑正是以类为基础建立起来的。我们闻明了四种基本的标准式直言命题</p>

<p>A命题:全称肯定命题</p>

<p>E命题:全称否定命题</p>

<p>Ⅰ命题:特称肯定命题</p>

<p>O命题:特称否定命题</p>

<p>探讨了命题的质,即肯定和否定,以及命题的量,即全称和特称。说明了周延的项与不周延的项</p>

<p>这几种直言命题之间的对当关系的种类:</p>

<p>命题之间的矛盾关系、反对关系、下反对关系以及上位式与下位式之间的差等关系。</p>

<p>并用个对当方阵图示了这几种关系,进而说明了一些基于传统方阵的直接推理。</p>

<p>其他三种直接推论:换位法、换质法和換质位法。</p>

<p>探讨存在含义问题。要保留传统对当方阵,只有做出一种假定,即全盘假定命题主项所指称的类总是有元素的一一这是现代逻辑极不赞同的。然后,我们又对本书通篇采用的布尔解释作了说明。布尔解释能保留传统逻辑对当方阵中的大部分内容,同时又避免了非空类的假定。在布尔解释中,特称命题,即称为I和O的命题之中有存在含义,但全称命题,即A和E则没有存在含义。我们也很细致地说明了采用这种解释的结果。</p>

<p>直言命题符号化与图示化的方法,包括使用文恩图,用交叉的圆加以恰当的标记或阴影来刻画类与类之间的关系。</p>

<p>有了这些必要的工具,我们就可以考察一一在接下来的两章中一建基于标准式直言命题之上的三段论,以及传统演绎逻辑在日常语言中的其他主要用途。</p>

    
  </div>

</article>

<hr/>

<ul class="pager"> 

  
  <li class="previous disabled">
    <a>&larr; Newer</a>
  </li>
  
  
  <li>
    <span class="page_number">Page: 1 of 2</span>
  </li>

  
  <li class="next">
    <a href="/page2">Older &rarr;</a>
  </li>
  

</ul>




		<footer>
			<hr/>
			<p>
				&copy; 2020 JY with <a href="http://jekyllrb.com/">Jekyll</a>. Theme: <a href="https://github.com/dbtek/dbyll">dbyll</a> by dbtek.
			</p>
		</footer>
	</div>

	<script type="text/javascript" src="/assets/resources/jquery/jquery.min.js"></script>
	<script type="text/javascript" src="/assets/resources/bootstrap/js/bootstrap.min.js"></script>
	<script type="text/javascript" src="/assets/js/app.js"></script>
</body>
</html>



